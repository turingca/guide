前言
----

http://www.chinastor.org/upload/2014-12/14122310427265.pdf

https://wenku.baidu.com/content/7da1c29fdd88d0d233d46a53?m=e743691db14cdff29ac60ea22a91b3ba&type=pic&src=6eb9168bdc140ad836a687d985fc8626.png

修摘自《JavaScript高级程序设计第3版》

第1章 JavaScript简介
-------------------

**1.1 JavaScript简史**

**1.2 JavaScript实现**

**1.2.1 ECMAScript**
**1.2.2 文档对象模型（DOM）**
**1.2.3 浏览器对象模型（BOM）**

**1.3 JavaScript版本**

**1.4 小结**

第2章 在HTML中使用JavaScript

**2.1 script元素**

**2.1.1 标签的位置**
**2.1.2 延迟脚本**
**2.1.3 异步脚本**
**2.1.4 在XHTML中的用法**
**2.1.5 不推荐使用的语法**

**2.2 嵌入代码与外部文件**

**2.3 文档模式**

**2.4 noscript元素**

**2.5 小结**

第3章 基本概念
--------------

**3.1 语法**
**3.1.1 区分大小写**
**3.1.2 标识符**
**3.1.3 注释**
**3.1.4 严格模式**
**3.1.5 语句**

**3.2 关键字和保留字**
**3.3 变量**
**3.4 数据类型**
**3.4.1 typeof操作符**
**3.4.2 Undefined类型**
**3.4.3 Null类型**
**3.4.4 Boolean类型**
**3.4.5 Number类型**
**3.4.6 String类型**
**3.4.7 Object类型**

**3.5 操作符**
**3.5.1 一元操作符**
**3.5.2 位操作符**
**3.5.3 布尔操作符**
**3.5.4 乘性操作符**
**3.5.5 加性操作符**
**3.5.6 关系操作符**
**3.5.7 相等操作符**
**3.5.8 条件操作符**
**3.5.9 赋值操作符**
**3.5.10 逗号操作符**

**3.6 语句**
**3.6.1 if语句**
**3.6.2 do-while语句**
**3.6.3 while语句**
**3.6.4 for语句**
**3.6.5 for-in语句**
**3.6.6 label语句**
**3.6.7 break和continue 语句**
**3.6.8 with语句**
**3.6.9 switch语句**

**3.7 函数**
**3.7.1 理解参数**
**3.7.2 没有重载**

**3.8 小结**

第4章 变量、作用域和内存问题
------------------------

本章内容
- 理解基本类型和引用类型的值
- 理解执行环境
- 理解垃圾收集

按照ECMA-262的定义，JavaScript的变量与其他语言的变量有很大区别。JavaScript变量松散类型的本质，决定了它只是在特定时间用于保存特定值的一个名字而已。由于不存在定义某个变量必须要保存何种数据类型值的规则，变量的值及其数据类型可以在脚本的生命周期内改变。尽管从某种角度看，这可能是一个既有趣又强大，同时又容易出问题的特性，但JavaScript变量实际的复杂程度还远不止如此。

**4.1 基本类型和引用类型的值**

ECMAScript变量可能包含两种不同数据类型的值：基本类型值和引用类型值。基本类型值指的是简单的数据段，而引用类型值指那些可能由多个值构成的对象。

在将一个值赋给变量时，解析器必须确定这个值是基本类型值还是引用类型值。第3章讨论了5种基本数据类型：Undefined、Null、Boolean、Number和String。这5种基本数据类型是按值访问的，因为可以操作保存在变量中的实际的值。

引用类型的值是保存在内存中的对象。与其他语言不同，JavaScript不允许直接访问内存中的位置，也就是说不能直接操作对象的内存空间。在操作对象时，实际上是在操作对象的引用而不是实际的对象。为此，引用类型的值是按引用访问的（这种说法不严密，当复制保存着对象的某个变量时，操作的是对象的引用。但在为对象添加属性时，操作的是实际的对象。——图灵社区“壮壮的前端之路”）。

在很多语言中，字符串以对象的形式来表示，因此被认为是引用类型的。ECMAScript放弃了这一传统。

**4.1.1 动态的属性**

定义基本类型值和引用类型值的方式是类似的：创建一个变量并为该变量赋值。但是，当这个值保存到变量中以后，对不同类型值可以执行的操作则大相径庭。对于引用类型的值，我们可以为其添加属性和方法，也可以改变和删除其属性和方法。请看下面的例子：

```javascript
var person = new Object();
person.name = "Nicholas";
alert(person.name); //"Nicholas"
```

以上代码创建了一个对象并将其保存在了变量person中。然后，我们为该对象添加了一个名为name的属性，并将字符串值"Nicholas"赋给了这个属性。紧接着，又通过alert()函数访问了这个新属性。如果对象不被销毁或者这个属性不被删除，则这个属性将一直存在。但是，我们不能给基本类型的值添加属性，尽管这样做不会导致任何错误。比如：

```javascript
var name = "Nicholas";
name.age = 27;
alert(name.age); //undefined
```

在这个例子中，我们为字符串name定义了一个名为age的属性，并为该属性赋值27。但在下一行访问这个属性时，发现该属性不见了。这说明只能给引用类型值动态地添加属性，以便将来使用。

**4.1.2 复制变量值**

除了保存的方式不同之外，在从一个变量向另一个变量复制基本类型值和引用类型值时，也存在不同。如果从一个变量向另一个变量复制基本类型的值，会在变量对象上创建一个新值，然后把该值复制到为新变量分配的位置上。来看一个例子：
```javascript
var num1 = 5;
var num2 = num1;
```
在此，num1中保存的值是5。当使用num1的值来初始化num2时，num2中也保存了值5。但num2中的5与num1中的5是完全独立的，该值只是num1中5的一个副本。此后，这两个变量可以参与任何操作而不会相互影响。图4-1形象地展示了复制基本类型值的过程。

当从一个变量向另一个变量复制引用类型的值时，同样也会将存储在变量对象中的值复制一份放到为新变量分配的空间中。不同的是，这个值的副本实际上是一个指针，而这个指针指向存储在堆中的一个对象。复制操作结束后，两个变量实际上将引用同一个对象。因此，改变其中一个变量，就会影响另一个变量，如下面的例子所示：
```javascript
var obj1 = new Object();
var obj2 = obj1;
obj1.name = "Nicholas";
alert(obj2.name);  //"Nicholas" 
```
首先，变量obj1保存了一个对象的新实例。然后，这个值被复制到了obj2中；换句话说，obj1和obj2都指向同一个对象。这样，当为obj1添加name属性后，可以通过obj2来访问这个属性，因为这两个变量引用的都是同一个对象。图4-2展示了保存在变量对象中的变量和保存在堆中的对象之间的这种关系。

**4.1.3 传递参数**

ECMAScript中所有函数的参数都是按值传递的。也就是说，把函数外部的值复制给函数内部的参数，就和把值从一个变量复制到另一个变量一样。基本类型值的传递如同基本类型变量的复制一样，而引用类型值的传递，则如同引用类型变量的复制一样。有不少开发人员在这一点上可能会感到困惑，因为访问变量有按值和按引用两种方式，而参数只能按值传递。

在向参数传递基本类型的值时，被传递的值会被复制给一个局部变量（即命名参数，或者用ECMAScript的概念来说，就是arguments对象中的一个元素）。在向参数传递引用类型的值时，会把这个值在内存中的地址复制给一个局部变量，因此这个局部变量的变化会反映在函数的外部。请看下面


**4.1.4 检测类型**

**4.2 执行环境及作用域**
**4.2.1 延长作用域链**
**4.2.2 没有块级作用域**

**4.3 垃圾收集**
**4.3.1 标记清除**
**4.3.2 引用计数**
**4.3.3 性能问题**
**4.3.4 管理内存**

**4.4 小结**

第5章 引用类型
--------------

**5.1 Object类型**
**5.2 Array类型**
**5.2.1 检测数组**
**5.2.2 转换方法**
**5.2.3 栈方法**
**5.2.4 队列方法**
**5.2.5 重排序方法**
**5.2.6 操作方法**
**5.2.7 位置方法**
**5.2.8 迭代方法**
**5.2.9 缩小方法**

**5.3 Date类型**
**5.3.1 继承的方法**
**5.3.1 日期格式化方法**
**5.3.1 日期/时间组件方法**

**5.4 RegExp类型**
**5.4.1 RegExp实例属性**
**5.4.2 RegExp实例方法**
**5.4.3 RegExp构造函数属性**
**5.4.4 模式的局限性**

**5.5 Function类型**
**5.5.1 没有重载（深入理解）**
**5.5.2 函数声明与函数表达式**
**5.5.3 作为值的函数**
**5.5.4 函数内部属性**
**5.5.5 函数属性和方法**

**5.6 基本包装类型**
**5.6.1 Boolean类型**
**5.6.2 Number类型**
**5.6.3 String类型**

**5.7 单体内置对象**
**5.7.1 Global对象**
**5.7.2 Math对象**
**5.8 小结**
