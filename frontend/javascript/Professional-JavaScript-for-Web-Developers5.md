第13章 事件
----------

**13.1 事件流**
**13.1.1 事件冒泡**
**13.1.2 事件捕获**
**13.1.3 DOM事件流**
**13.2 事件处理程序**
**13.2.1 HTML事件处理程序**
**13.2.2 DOM0级事件处理程序**
**13.2.3 DOM2级事件处理程序**
**13.2.4 IE事件处理程序**
**13.2.5 跨浏览器的事件处理程序**

**13.3 事件对象**
**13.3.1 DOM中的事件对象**
**13.3.2 IE中的事件对象**
**13.3.3 跨浏览器的事件对象**

**13.4 事件类型**
**13.4.1 UI事件**
**13.4.2 焦点事件**
**13.4.3 鼠标与滚轮事件**
**13.4.4 键盘与文本事件**
**13.4.5 复合事件**
**13.4.6 变动事件**
**13.4.7 HTML5事件**
**13.4.8 设备事件**
**13.4.9 触摸与手势事件**

**13.5 内存与性能**
**13.5.1 事件委托**
**13.5.2 移除事件处理程序**

**13.6 模拟事件**
**13.6.1 DOM中的事件模拟**
**13.6.2 IE中的事件模拟**
**13.7 小结**

第14章 表单脚本
--------------

**14.1 表单的基础知识**
**14.1.1 提交表单**
**14.1.2 重置表单**
**14.1.2 表单字段**

**14.2 文本框脚本**
**14.2.1 选择文本**
**14.2.2 过滤输入**
**14.2.3 自动切换焦点**
**14.2.4 HTML5约束验证API**

**14.3 选择框脚本**
**14.3.1 选择选项**
**14.3.2 添加选项**
**14.3.3 移除选项**
**14.3.4 移动和重排选项**

**14.4 表单序列化**
**14.5 富文本编辑**
**14.5.1 使用contenteditable属性**
**14.5.2 操作富文本**
**14.5.3 富文本选区**
**14.5.4 表单与富文本**
**14.6 小结**

第15章 使用Canvas绘图
---------------------

**15.1 基本用法**
**15.2 2D上下文**
**15.2.1 填充和描边**
**15.2.2 绘制矩形**
**15.2.3 绘制路径**
**15.2.4 绘制文本**
**15.2.5 变换**
**15.2.6 绘制图像**
**15.2.7 阴影**
**15.2.8 渐变**
**15.2.9 模式**
**15.2.10 使用图像数据**
**15.2.11 合成**

**15.3 WebGL**
**15.3.1 类型化数组**
**15.3.2 WebGL上下文**
**15.3.3 支持**
**15.4 小结**

第16章 HTML5脚本编程
-------------------

**16.1 跨文档消息传递**
**16.2 原生拖放**
**16.2.1 拖放事件**
**16.2.2 自定义放置目标**
**16.2.3 dataTransfer对象**
**16.2.4 dropEffect与effectAllowed**
**16.2.5 可拖动**
**16.2.6 其他成员**

**16.3 媒体元素**
**16.3.1 属性**
**16.3.2 事件**
**16.3.3 自定义媒体播放器**
**16.3.4 检测编码器的支持情况**
**16.3.5 Audio类型**
**16.4 历史状态管理**
**16.5 小结**

第17章 错误处理与调试
---------------------

**17.1 浏览器报告的错误**
**17.1.1 IE**
**17.1.2 Firefox**
**17.1.3 Safari**
**17.1.4 Opera**
**17.1.5 Chrome**

**17.2 错误处理**
**17.2.1 try-catch语句**
**17.2.2 抛出错误**
**17.2.3 错误(error)事件**
**17.2.4 处理错误的策略**
**17.2.5 常见的错误类型**
**17.2.6 区分致命错误和非致命错误**
**17.2.7 把错误记录到服务器**
**17.3 调试技术**
**17.3.1 将消息记录到控制台**
**17.3.1 将消息记录到当前页面**
**17.3.1 抛出错误**

**17.4 常见的IE错误**
**17.4.1 操作终止**
**17.4.2 无效字符**
**17.4.3 未找到成员**
**17.4.4 未知运行时错误**
**17.4.5 语法错误**
**17.4.6 系统无法找到指定资源**
**17.5 小结**

第18章 JavaScript与XML
---------------------

**18.1 浏览器对XML DOM的支持**
**18.1.1 DOM2级核心**
**18.1.2 DOMParser类型**
**18.1.3 XMLSerializer类型**
**18.1.4 IE8及之前版本中的XML**
**18.1.5 跨浏览器处理XML**
**18.2 浏览器对XPath的支持**
**18.2.1 DOM3级XPath**
**18.2.2 IE中的XPath**
**18.2.3 跨浏览器使用XPath**
**18.3 浏览器对XSLT的支持**
**18.3.1 IE中的XSLT**
**18.3.2 XSLTProcessor类型**
**18.3.3 跨浏览器使用XSLT**
**18.4 小结**

第19章 E4X
----------

**19.1 E4X的类型**
**19.1.1 XML类型**
**19.1.2 XMLList类型**
**19.1.3 Namespace类型**
**19.1.4 QName类型**
**19.2 一般用法**
**19.2.1 访问特性**
**19.2.2 其他节点类型**
**19.2.3 查询**
**19.2.4 构建和操作XML**
**19.2.5 解析和序列化L**
**19.2.6 命名空间**
**19.3 其他变化**
**19.4 全面启用E4X**
**19.5 小结**

第20章 JSON
-----------

**20.1 语法**
**20.1.1 简单值**
**20.1.2 对象**
**20.1.3 数组**
**20.2 解析与序列化**
**20.2.1 JSON对象**
**20.2.2 序列化选项**
**20.2.3 解析选项**
**20.3 小结**

第21章 Ajax与Comet
------------------

**21.1 XMLHttpRequest对象**
**21.1.1 XHR的用法**
**21.1.2 HTTP头部信息**
**21.1.3 GET请求**
**21.1.4 POST请求**

**21.2.1 FormData**
**21.2.2 超时设定**
**21.2.3 overrideMimeType()方法**
**21.3 进度事件**
**21.3.1 load事件**
**21.3.2 progress事件**
**21.4 跨域资源共享**
**21.4.1 IE对CORS的实现**
**21.4.2 其他浏览器对CORS的实现**
**21.4.3 Preflighted Requests**
**21.4.4 带凭据的请求**
**21.4.5 跨浏览器的CORS**

**21.5 其他跨域技术**
**21.5.1 图像Ping**
**21.5.2 JSONP**
**21.5.3 Commet**
**21.5.4 服务器发送事件**
**21.5.5 Web Sockets**
**21.5.6 SSE与Web Sockets**
**21.6 安全**
**21.7 小结**

第22章 高级技巧
---------------

本章内容
- 使用高级函数
- 防篡改对象
- Yielding Timers

JavaScript是一种极其灵活的语言，具有多种使用风格。一般来说，编写JavaScript要么使用过程方式，要么使用面向对象方式。然而，由于它天生的动态属性，这种语言还能使用更为复杂和有趣的模式。这些技巧要利用ECMAScript的语言特点、BOM扩展和DOM功能来获得强大的效果。

**22.1 高级函数**

函数是JavaScript中最有趣的部分之一。它们本质上是十分简单和过程化的，但也可以是非常复杂和动态的。一些额外的功能可以通过使用闭包来实现。此外，由于所有的函数都是对象，所以使用函数指针非常简单。这些令JavaScript函数不仅有趣而且强大。以下几节描绘了几种在JavaScript中使用函数的高级方法。

**22.1.1 安全的类型检测**

JavaScript内置的类型检测机制并非完全可靠。事实上，发生错误否定及错误肯定的情况也不在少数。比如说typeof操作符吧，由于它有一些无法预知的行为，经常会导致检测数据类型时得到不靠谱的结果。Safari（直至第4版）在对正则表达式应用typeof操作符时会返回"function"，因此很难确定某个值到底是不是函数。

再比如，instanceof操作符在存在多个全局作用域（像一个页面包含多个frame）的情况下，也是问题多多。一个经典的例子（第5章也提到过）就是像下面这样将对象标识为数组。
```
var isArray = value instanceof Array;
```
以上代码要返回true，value必须是一个数组，而且还必须与Array构造函数在同个全局作用域中。（别忘了，Array是window的属性。）如果value是在另个frame中定义的数组，那么以上代码就会返回false。

在检测某个对象到底是原生对象还是开发人员自定义的对象的时候，也会有问题。出现这个问题的原因是浏览器开始原生支持JSON对象了。因为很多人一直在使用Douglas Crockford的JSON库，而该库定义了一个全局JSON对象。于是开发人员很难确定页面中的JSON对象到底是不是原生的。

解决上述问题的办法都一样。大家知道，在任何值上调用Object原生的toString()方法，都会返回一个[object NativeConstructorName]格式的字符串。每个类在内部都有一个`[[Class]]`属性，这个属性中就指定了上述字符串中的构造函数名。举个例子吧。
```
alert(Object.prototype.toString.call(value));    //"[object Array]" 
```
由于原生数组的构造函数名与全局作用域无关，因此使用toString()就能保证返回一致的值。利用这一点，可以创建如下函数：
```
function isArray(value) {
    return Object.prototype.toString.call(value) == "[object Array]"; 
}
```

同样，也可以基于这一思路来测试某个值是不是原生函数或正则表达式：
```
function isFunction(value) {
    return Object.prototype.toString.call(value) == "[object Function]"; 
}
function isRegExp(value) {
    return Object.prototype.toString.call(value) == "[object RegExp]";
}
```

不过要注意，对于在IE中以COM对象形式实现的任何函数，isFunction()都将返回false（因为它们并非原生的JavaScript函数，请参考第10章中更详细的介绍）。

这一技巧也广泛应用于检测原生JSON对象。Object的toString()方法不能检测非原生构造函数的构造函数名。因此，开发人员定义的任何构造函数都将返回`[object  Object]`。有些JavaScript库会包含与下面类似的代码。
```
var isNativeJSON = window.JSON && Object.prototype.toString.call(JSON) == "[object JSON]";
```

在Web开发中能够区分原生与非原生JavaScript对象非常重要。只有这样才能确切知道某个对象到底有哪些功能。这个技巧可以对任何对象给出正确的结论。

请注意，Object.prototpye.toString()本身也可能会被修改。本节讨论的技巧假设Object.prototpye.toString()是未被修改过的原生版本。

**22.1.2 作用域安全的构造函数**

第6章讲述了用于自定义对象的构造函数的定义和用法。你应该还记得，构造函数其实就是一个使用new操作符调用的函数。当使用new调用时，构造函数内用到的this对象会指向新创建的对象实例，如下面的例子所示：
```
function Person(name, age, job) {
    this.name = name;
    this.age = age;
    this.job = job;
}
var person = new Person("Nicholas", 29, "Software Engineer");
```

上面这个例子中，Person构造函数使用this对象给三个属性赋值：name、age和job。当和new操作符连用时，则会创建一个新的Person对象，同时会给它分配这些属性。问题出在当没有使用new操作符来调用该构造函数的情况上。由于该this对象是在运行时绑定的，所以直接调用Person()，this会映射到全局对象window上，导致错误对象属性的意外增加。例如：
```
var person = Person("Nicholas", 29, "Software Engineer");
alert(window.name);  //"Nicholas"
alert(window.age);   //29
alert(window.job);   //"Software Engineer"
```

这里，原本针对Person实例的三个属性被加到window对象上，因为构造函数是作为普通函数调用的，忽略了new操作符。这个问题是由this对象的晚绑定造成的，在这里this被解析成了window对象。由于window的name属性是用于识别链接目标和frame的，所以这里对该属性的偶然覆盖可能会导致该页面上出现其他错误。这个问题的解决方法就是创建一个作用域安全的构造函数。作用域安全的构造函数在进行任何更改前，首先确认this对象是正确类型的实例。如果不是，那么会创建新的实例并返回。请看以下例子：
```
function Person(name, age, job) {
    if (this instanceof Person) {
        this.name = name;
        this.age = age;
        this.job = job;
    } else { 
        return new Person(name, age, job);
    }
}
var person1 = Person("Nicholas", 29, "Software Engineer");
alert(window.name); //""
alert(person1.name);//"Nicholas"
var person2 = new Person("Shelby", 34, "Ergonomist");
alert(person2.name);//"Shelby"
```

这段代码中的Person构造函数添加了一个检查并确保this对象是Person实例的if语句，它表示要么使用new操作符，要么在现有的Person实例环境中调用构造函数。任何一种情况下，对象初始化都能正常进行。如果this并非Person的实例，那么会再次使用new操作符调用构造函数并返回结果。最后的结果是，调用Person构造函数时无论是否使用new操作符，都会返回一个Person的新实例，这就避免了在全局对象上意外设置属性。

关于作用域安全的构造函数的贴心提示。实现这个模式后，你就锁定了可以调用构造函数的环境。如果你使用构造函数窃取模式的继承且不使用原型链，那么这个继承很可能被破坏。这里有个例子：
```
function Polygon(sides) {
    if (this instanceof Polygon) {
        this.sides = sides;
        this.getArea = function() {
            return 0;
        };
    } else {
        return new Polygon(sides);
    }
}
function Rectangle(width, height) {
    Polygon.call(this, 2);
    this.width = width;
    this.height = height;
    this.getArea = function() {
        return this.width * this.height;
    };
}
var rect = new Rectangle(5, 10);
alert(rect.sides); //undefined
```

在这段代码中，Polygon构造函数是作用域安全的，然而Rectangle构造函数则不是。新创建一个Rectangle实例之后，这个实例应该通过Polygon.call()来继承Polygon的sides属性。但是，由于Polygon构造函数是作用域安全的，this对象并非Polygon的实例，所以会创建并返回一个新的Polygon对象。Rectangle构造函数中的this对象并没有得到增长，同时Polygon.call()返回的值也没有用到，所以Rectangle实例中就不会有sides属性。如果构造函数窃取结合使用原型链或者寄生组合则可以解决这个问题。考虑以下例子：
```
function Polygon(sides) {
    if (this instanceof Polygon) {
        this.sides = sides;
        this.getArea = function() {
            return 0;
        };
    } else {
        return new Polygon(sides);
    }
}
function Rectangle(width, height) {
    Polygon.call(this, 2);
    this.width = width;
    this.height = height;
    this.getArea = function() {
        return this.width * this.height;
    };
}
Rectangle.prototype = new Polygon();
var rect = new Rectangle(5, 10);
alert(rect.sides); //2
```

上面这段重写的代码中，一个Rectangle实例也同时是一个Polygon实例，所以Polygon.call()会照原意执行，最终为Rectangle实例添加了sides属性。多个程序员在同一个页面上写JavaScript代码的环境中，作用域安全构造函数就很有用了。届时，对全局对象意外的更改可能会导致一些常常难以追踪的错误。除非你单纯基于构造函数窃取来实现继承，推荐作用域安全的构造函数作为最佳实践。

**22.1.3 惰性载入函数**

因为浏览器之间行为的差异，多数JavaScript代码包含了大量的if语句，将执行引导到正确的代码中。看看下面来自上一章的createXHR()函数。
```
function createXHR() {
    if (typeof XMLHttpRequest != "undefined") {
        return new XMLHttpRequest();
    } else if (typeof ActiveXObject != "undefined") {
        if (typeof arguments.callee.activeXString != "string") {
            var versions = ["MSXML2.XMLHttp.6.0",
                           "MSXML2.XMLHttp.3.0",                             "MSXML2.XMLHttp"],
                           i,
                           len;
            for (i=0, len=versions.length; i < len; i++) {
                try {
                    new ActiveXObject(versions[i]);
                    arguments.callee.activeXString = versions[i];
                    break;
                } catch (ex) {
                    //跳过
                }
            }
        }
        return new ActiveXObject(arguments.callee.activeXString);
    } else {
        throw new Error("No XHR object available.");
    }
}
```

每次调用createXHR()的时候，它都要对浏览器所支持的能力仔细检查。首先检查内置的XHR，然后测试有没有基于ActiveX的XHR，最后如果都没有发现的话就抛出一个错误。每次调用该函数都是这样，即使每次调用时分支的结果都不变：如果浏览器支持内置XHR，那么它就一直支持了，那么这种测试就变得没必要了。即使只有一个if语句的代码，也肯定要比没有if语句的慢，所以如果if语句不必每次执行，那么代码可以运行地更快一些。解决方案就是称之为惰性载入的技巧。惰性载入表示函数执行的分支仅会发生一次。有两种实现惰性载入的方式，第一种就是在函数被调用时再处理函数。在第一次调用的过程中，该函数会被覆盖为另外一个按合适方式执行的函数，这样任何对原函数的调用都不用再经过执行的分支了。例如，可以用下面的方式使用惰性载入重写createXHR()。

```
function createXHR(){
    if (typeof XMLHttpRequest != "undefined") {
        createXHR = function(){
            return new XMLHttpRequest();
        };
    } else if (typeof ActiveXObject != "undefined") {
        createXHR = function() {
            if (typeof arguments.callee.activeXString != "string") {
                var versions = ["MSXML2.XMLHttp.6.0",
                "MSXML2.XMLHttp.3.0",
                "MSXML2.XMLHttp"],
                i,
                len;
                for (i=0, len=versions.length; i < len; i++) {
                    try {
                        new ActiveXObject(versions[i]);    arguments.callee.activeXString = versions[i];
                        break;
                    } catch (ex){
                        //skip
                    }
                }
            }
            return new ActiveXObject(arguments.callee.activeXString);
        };
    } else {
        createXHR = function() {
            throw new Error("No XHR object available.");
        };
    }
    return createXHR();
}
```

在这个惰性载入的createXHR()中，if语句的每一个分支都会为createXHR变量赋值，有效覆盖了原有的函数。最后一步便是调用新赋的函数。下一次调用createXHR()的时候，就会直接调用被分配的函数，这样就不用再次执行if语句了。第二种实现惰性载入的方式是在声明函数时就指定适当的函数。这样，第一次调用函数时就不会损失性能了，而在代码首次加载时会损失一点性能。以下就是按照这一思路重写前面例子的结果。
```
var createXHR = (function(){
    if (typeof XMLHttpRequest != "undefined") {
        return function() {
            return new XMLHttpRequest();
        };
    } else if (typeof ActiveXObject != "undefined") {
        return function() {
            if (typeof arguments.callee.activeXString != "string") {
                var versions = ["MSXML2.XMLHttp.6.0",
                "MSXML2.XMLHttp.3.0",
                "MSXML2.XMLHttp"],
                i,
                len;
                for (i=0, len=versions.length; i < len; i++) {
                    try {
                        new ActiveXObject(versions[i]);
                        arguments.callee.activeXString = versions[i]; break;
                    } catch (ex){
                        //skip
                    }
                }
            }
            return new ActiveXObject(arguments.callee.activeXString);
        };
    } else {
        return function() {
            throw new Error("No XHR object available.");
        };
    }
})();
```

这个例子中使用的技巧是创建一个匿名、自执行的函数，用以确定应该使用哪一个函数实现。实际的逻辑都一样。不一样的地方就是第一行代码（使用var定义函数）、新增了自执行的匿名函数，另外每个分支都返回正确的函数定义，以便立即将其赋值给createXHR()。惰性载入函数的优点是只在执行分支代码时牺牲一点儿性能。至于哪种方式更合适，就要看你的具体需求而定了。不过这两种方式都能避免执行不必要的代码。


**22.1.4 函数绑定**

另一个日益流行的高级技巧叫做函数绑定。函数绑定要创建一个函数，可以在特定的this环境中以指定参数调用另一个函数。该技巧常常和回调函数与事件处理程序一起使用，以便在将函数作为变量传递的同时保留代码执行环境。请看以下例子：
```
var handler = {
    message: "Event handled",
    handleClick: function(event) {
        alert(this.message); 
    } }; var btn = document.getElementById("my-btn"); EventUtil.addHandler(btn, "click", handler.handleClick); 在上面这个例子中，创建了一个叫做handler的对象。handler.handleClick()方法被分配为一个DOM按钮的事件处理程序。当按下该按钮时，就调用该函数，显示一个警告框。虽然貌似警告框应该显示Event  handled，然而实际上显示的是undefiend。这个问题在于没有保存handler.handleClick()的环境，所以this对象最后是指向了DOM按钮而非handler（在IE8中，this指向window。）可以如下面例子所示，使用一个闭包来修正这个问题。var handler = {     message: "Event handled",     handleClick: function(event){         alert(this.message);     } }; var btn = document.getElementById("my-btn"); EventUtil.addHandler(btn, "click", function(event){     handler.handleClick(event); });

这个解决方案在onclick事件处理程序内使用了一个闭包直接调用handler.handleClick()。当然，这是特定于这段代码的解决方案。创建多个闭包可能会令代码变得难于理解和调试。因此，很多JavaScript库实现了一个可以将函数绑定到指定环境的函数。这个函数一般都叫bind()。一个简单的bind()函数接受一个函数和一个环境，并返回一个在给定环境中调用给定函数的函数，并且将所有参数原封不动传递过去。语法如下：function bind(fn, context){     return function(){         return fn.apply(context, arguments);     }; }

这个函数似乎简单，但其功能是非常强大的。在bind()中创建了一个闭包，闭包使用apply()调用传入的函数，并给apply()传递context对象和参数。注意这里使用的arguments对象是内部函数的，而非bind()的。当调用返回的函数时，它会在给定环境中执行被传入的函数并给出所有参数。bind()函数按如下方式使用：var handler = {     message: "Event handled",     handleClick: function(event){         alert(this.message);     } }; var btn = document.getElementById("my-btn"); EventUtil.addHandler(btn, "click", bind(handler.handleClick, handler));

在这个例子中，我们用bind()函数创建了一个保持了执行环境的函数，并将其传给EventUtil. addHandler()。event对象也被传给了该函数，如下所示：var handler = {     message: "Event handled",     handleClick: function(event){         alert(this.message + ":" + event.type);     } }; var btn = document.getElementById("my-btn"); EventUtil.addHandler(btn, "click", bind(handler.handleClick, handler));

handler.handleClick()方法和平时一样获得了event对象，因为所有的参数都通过被绑定的函数直接传给了它。ECMAScript 5为所有函数定义了一个原生的bind()方法，进一步简单了操作。换句话说，你不用再自己定义bind()函数了，而是可以直接在函数上调用这个方法。例如：

var handler = {     message: "Event handled",     handleClick: function(event){ alert(this.message + ":" + event.type);     } }; var btn = document.getElementById("my-btn"); EventUtil.addHandler(btn, "click", handler.handleClick.bind(handler));

原生的bind()方法与前面介绍的自定义bind()方法类似，都是要传入作为this值的对象。支持原生bind()方法的浏览器有IE9+、Firefox 4+和Chrome。只要是将某个函数指针以值的形式进行传递，同时该函数必须在特定环境中执行，被绑定函数的效用就突显出来了。它们主要用于事件处理程序以及 setTimeout()和 setInterval()。然而，被绑定函数与普通函数相比有更多的开销，它们需要更多内存，同时也因为多重函数调用稍微慢一点，所以最好只在必要时使用。

**22.1.5 函数柯里化**
**22.2 防篡改对象**
**22.2.1 不可扩展对象**
**22.2.2 密封的对象**
**22.2.3 冻结的对象**
**22.3 高级定时器**
**22.3.1 重复的定时器**
**22.3.2 Yielding Processes**
**22.3.3 函数节流**
**22.4 自定义事件**
**22.5 拖放**
**22.5.1 修缮拖放功能**
**22.5.2 添加自定义事件**
**22.6 小结**

第23章 离线应用与客户端存储
--------------------------

**23.1 离线检测**
**23.2 应用缓存**
**23.3 数据存储**
**23.3.1 Cookie**
**23.3.2 IE用户数据**
**23.3.3 Web存储机制**
**23.3.4 IndexedDB**
**23.4 小结**

第24章 最佳实践
---------------

**24.1 可维护性**
**24.1.1 什么是可维护的代码**
**24.1.2 代码约定**
**24.1.3 松散耦合**
**24.1.4 编程实践**
**24.2 性能**
**24.2.1 注意作用域**
**24.2.2 选择正确的方法**
**24.2.3 最小化语句数**
**24.2.4 优化DOM交互**
**24.3 部署**
**24.3.1 构建过程**
**24.3.2 验证**
**24.3.3 压缩**
**24.4 小结**

第25章 新兴的API
----------------

**25.1 requestAnimationFrame()**
**25.1.1 早期动画循环**
**25.1.2 循环间隔的问题**
**25.1.3 mozRequestAnimation-Frame**
**25.1.4 webkitRequestAnimationFrame与msRequestAnimationFrame**
**25.2 Page Visibility API**
**25.3 Geolocation API**
**25.4 File API**
**25.4.1 FileReader类型**
**25.4.2 读取部分内容**
**25.4.3 对象URL**
**25.4.4 读取拖动的文件**
**25.4.5 使用XHR上传文件**
**25.5 Web计时**
**25.6 Web Workers**
**25.6.1 使用Worker**
**25.6.2 Worker全局作用域**
**25.6.3 包含其他脚本**
**25.6.4 Web Workers的未来**
**25.7 小结**

附录A ECMAScript Harmony
-----------------------

附录B 严格模式
--------------

附录C JavaScript库
------------------

附录D JavaScript工具
--------------------
















