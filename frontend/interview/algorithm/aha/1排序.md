第1节　最快最简单的排序——桶排序

以下并不是真正的桶排序算法
```javascript
var arr = new Array(11);
var orderArr = [3, 1, 2, 0, 8, 7, 5, 6, 4, 9, 10, 0, 1];
var i, j, t, n;
for (i= 0; i<= arr.length-1; i++) { // 循环N次
    arr[i] = 0;
}
for (i = 0; i<=orderArr.length-1; i++) { // 循环M次
    arr[orderArr[i]]++;
}
/**
 * 从大到小排序
 */
for (i = arr.length-1; i>=0;i--) { // 两for循环M+N次
    for(j =1;j<= arr[i];j++) {
        console.log(i);
    }
}
/**
 * 从小到大排序
 */
for (i =0 ; i<= arr.length-1;i++) { // 两for循环M+N次
    for(j =1;j<= arr[i];j++) {
        console.log(i);
    }
}
```
用大写字母O来表示时间复杂度，因此该算法的时间复杂度是```O(M+N+M+N)```即```O(2*(M+N))```因时间复杂度可以忽略较小的常数，最终桶排序的时间复杂度为```O(M+N)```;

第2节　邻居好说话——冒泡排序

冒泡排序的基本思想是:每次比较两个相邻的元素，如果它们的顺序错误就把它们交换过来。

```javascript
var orderArr = [3, 1, 2, 0, 8, 7, 5, 6, 4, 9, 10, 0, 1];
var i, j, t;
var n = orderArr.length;
/**
 * 从大到小排序
 */
for (i = 1;i <= n-1;i++) { // 循环N次
    for(j = 0;j <= n-i;j++) { // 循环N次
        if(orderArr[j] < orderArr[j+1]) {
            t = orderArr[j];
            orderArr[j] = orderArr[j+1];
            orderArr[j+1] = t;
        }
    }
}
/**
 * 从小到大排序
 */
for (i = 1;i <= n-1;i++) { // 循环N次
    for(j = 0;j <= n-i;j++) { // 循环N次
        if(orderArr[j] > orderArr[j+1]) {
            t = orderArr[j];
            orderArr[j] = orderArr[j+1];
            orderArr[j+1] = t;
        }
    }
}
for (i = 0; i <= n-1; i++) {
    console.log(orderArr[i]);
}
```

冒泡排序的核心部分是双重嵌套循环。不难看出冒泡排序的时间复杂度是 O(N的二次方)。这是 一个非常高的时间复杂度。冒泡排序早在 1956 年就有人开始研究，之后有很多人都尝试过 对冒泡排序进行改进，但结果却令人失望。如 Donald E. Knuth(中文名为高德纳，1974 年 图灵奖获得者)所说:“冒泡排序除了它迷人的名字和导致了某些有趣的理论问题这一事实 之外，似乎没有什么值得推荐的。”

冒泡排序解决了桶排序浪费空间的问题，但在算法的执行效率上却牺牲了很多。

第3节 最常用的排序——快速排序

```javascript
var orderArr = [3, 1, 2, 0, 8, 7, 5, 6, 4, 9, 10, 0, 1];
var n = orderArr.length;
function quicksort(left, right) {
    var i, j, t, temp;
    if(left > right) return;
    temp = orderArr[left]; // 基准数
    i = left;
    j = right;
    while(i!=j) {
        // 顺序很重要，要先从右往左找
        while(orderArr[j]>=temp && i<j) {
            j--;
        }
        // 再从左往右找
        while(orderArr[i]<=temp && i<j) {
            i++
        }
        // 交换两个数在数组中的位置，从小到大排序
        if(i<j) {
            t=orderArr[i];
            orderArr[i]=orderArr[j];
            orderArr[j]=t;
        }
    }
    // 最终将基准数归位
    orderArr[left]=orderArr[i];
    orderArr[i]=temp;
    quicksort(left, i-1);//继续处理左边的，这里是一个递归的过程
    quicksort(i+1, right);//继续处理右边的，这里是一个递归的过程
}

quicksort(0, n-1);
for(var i= 0; i < n; i++) {
    console.log(orderArr[i]);
}
```

快速排序之所以比较快，是因为相比冒泡排序，每次交换是跳跃式的。每次排序的时候 设置一个基准点，将小于等于基准点的数全部放到基准点的左边，将大于等于基准点的数全 部放到基准点的右边。这样在每次交换的时候就不会像冒泡排序一样只能在相邻的数之间进 行交换，交换的距离就大得多了。因此总的比较和交换次数就少了，速度自然就提高了。当 然在最坏的情况下，仍可能是相邻的两个数进行了交换。因此快速排序的最差时间复杂度和 冒泡排序是一样的，都是 O(N的二次方)，它的平均时间复杂度为O(NlogN)。其实快速排序是基于一 种叫做“二分”的思想。

如果你对快速排序感兴趣，可以去看看东尼·霍尔1962年在 Computer Journal 发表的论文“Quicksort”以及《算法导论》的第七章。

本章三种排序算法的时间复杂度。桶排序是最快的，它的时间复杂度是 O(N+M);冒泡排序是 O(N的二次方);快速排序是 O(NlogN)。

排序算法还有很多，例如我在《啊哈 C!思考快你一步》一书中讲过的选择排序，另外 还有计数排序、基数排序、插入排序、归并排序和堆排序等等。堆排序是基于二叉树的排序， 我会在后面的章节讲到。

第四节 排序和去重


