##深度优先搜索Depth First Search，DFS

1.输入一个数n，输出1～n的全排列
```javascript
var a = [];
var book = [];
var n = 3;;
for(var i = 1; i <= n; i++) {
    book[i] = 0;
}
function dfs(step) {
    var i;
    if(step == n + 1) {
        for(var i = 1; i <= n; i++) {
            console.log(a[i]);
        }
        return;
    }

    for(i=1;i<=n;i++) {
        if(book[i] == 0) {
            a[step] = i;
            book[i] = 1;
            dfs(step + 1);
            book[i] = 0;
        }
    }
    return;
}
dfs(1);
```

2.口口口 + 口口口 = 口口口

```javascript 
var a = [], book = [], total = 0;
for(var i = 1; i <= 9; i++) {
    book[i] = 0;
}
function dfs(step) {
    var i;
    if(step == 10) {
        if(a[1]*100 + a[2]*10 + a[3] + a[4]*100 + a[5]*10 + a[6] == a[7]*100 + a[8]*10 + a[9]) {
            total++;
            console.log(a[1]+""+a[2]+""+a[3]+"+"+a[4]+""+a[5]+""+a[6]+"="+a[7]+""+a[8]+""+a[9]);
        }
        return;
    }
    for(i=1;i<=9;i++) {
        if(book[i]==0) {
            a[step] = i;
            book[i] = 1;
            dfs(step+1);
            book[i] = 0;
        }
    }
    return;
}
dfs(1);
console.log(total/2);
```

3. n行m列的迷宫a，求点(x,y)到点(p,q)的最短路径，0表示空地，1表示障碍物。


```javascript
var min=99999999;
// 二维数组迷宫
var a = [
    [0, 0, 1, 0], 
    [0, 0, 0, 0],
    [0, 0, 1, 0],
    [0, 1, 0, 0],
    [0, 0, 0, 1]
];
var n = 5;
var m = 4;
var p = 3;
var q = 2;
// 二维数组
var book = new Array(10);
for(var i = 0; i < book.length; i++) {
    book[i] = new Array(10);
}
for(var i = 0; i < book.length; i++) {
    for(var j = 0; j < book[i].length; j++) {
        book[i][j] = 0;
    }
}
// 走法
var next = [[0,1],[1,0],[0,-1],[-1,0]];
function dfs(x, y, step) {
    var tx, ty, k;
    if(x == p && y == q) {
        if(step < min) {
            min = step;
        }
        return;
    }
    // 枚举四种走法
    for(k = 0; k <= 3; k++) {
        // 计算下一个点的坐标
        tx = x + next[k][0];
        ty = y + next[k][1];
        // 判断是否越界
        if(tx < 0 || tx > n-1 || ty < 0 || ty > m-1) {
            continue;
        }
        // 判断该点是否为障碍物或者已经在路径中
        if(a[tx][ty] == 0 && book[tx][ty] == 0) {
            book[tx][ty] = 1; // 标记这个点已经走过
            dfs(tx, ty, step+1); // 开始尝试下一个点
            book[tx][ty] = 0; // 尝试结束，取消这个点的标记
        }
    }
    return;
}
dfs(0,0,0);
// 输出最短步数
console.log(min);
```


## 广度优先搜索Breadth First Search，BFS，也称为宽度优先搜索





