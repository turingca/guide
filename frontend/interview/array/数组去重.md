
```js
/**
 * 去除数组中重复的元素
 */

var arr = [1, 1, 2, "2", 3, 4, 5, 6, 7, 8, 9, 0, "a", "a", "b"];
// 双循环去重，效率低
Array.prototype.unique = function() {
    var newarr = [];
    var flag = true;
    for(var i = 0; i < this.length; i++) {
        for(var j = 0; j < newarr.length; j++) {
            if(newarr[j] === this[i]) {
                flag = false;
                break;
            }
            else {
                flag = true;
            }
        }
        if(flag) {
            newarr.push(this[i])
        }
    }
    return newarr;
};
console.log(arr.unique());

// 双循环去重，效率低
Array.prototype.unique2 = function() {
    var newarr = [];
    var flag = true;
    var i = this.length;
    var j = 0;
    while (--i >= 0) {
        j = newarr.length;
        while(--j >= 0) {
            flag = newarr[j] !== this[i];
            if(!flag) {
                break;
            }
        }
        flag && newarr.push(this[i]);
    }
    return newarr.reverse();
}
console.log(arr.unique2());

// 对象去重法，但是数组的元素数据类型变了
Array.prototype.unique3 = function() {
    var obj = {}, newarr = [];
    for(var i = 0; i < this.length; i++) {
        obj[this[i]] = "";
    }
    for(var items in obj) {
        newarr.push(items);
    }
    return newarr;
}
console.log(arr.unique3());

// 对象去重法优化，但是数组的元素数据类型变了
Array.prototype.unique4 = function() {
    var obj = {}, newarr = [];
    // 着重优化的是循环，
    for(var i = this.length-1; i >= 0; i--) {
        obj[this[i]] = "";
    }
    for(var items in obj) {
        newarr.push(items);
    }
    return newarr;
}
console.log(arr.unique4());

// 保证了数据类型不变，但是字符串类型的“数字”和真正的数字无法区分
Array.prototype.unique5 = function() {
    var obj = {}, newarr = [];
    // 着重优化的是循环，
    for(var i = this.length-1; i >= 0; i--) {
        if(obj[this[i]] === undefined) {
            obj[this[i]] = "";
            newarr.push(this[i]);
        }
    }
    return newarr;
}
console.log(arr.unique5());

// 保证了数据类型不变，并且可以区分字符串类型的“数字”和真正的数字
Array.prototype.unique6 = function() {
    var obj = {}, newarr = [];
    // 着重优化的是循环，
    for(var i = this.length-1; i >= 0; i--) {
        if(obj[this[i]] === undefined || obj[this[i]] !== this[i]) {
            obj[this[i]] = this[i];
            newarr.push(this[i]);
        }
    }
    return newarr;
}
console.log(arr.unique6());

// 保证了数据类型不变，并且可以区分字符串类型的“数字”和真正的数字
Array.prototype.unique7 = function() {
    var obj = {}, newarr = [], i = this.length;
    while(--i > 0) {
        (obj[this[i]] === undefined || obj[this[i]] !== this[i]) && (obj[this[i]] = this[i], newarr.push(this[i]));
    }
    return newarr.reverse();
}
console.log(arr.unique7());

// 正则表达式法，改变了数据类型
var arr = [1, 1, 2, "2", 3, 4, 5, 6, 7, 8, 9, 0, "a", "a", "b"];
Array.prototype.uniqueRegex = function() {
    return this.join(",").match(/([^,]+)(?!.*\1)/ig);
}
console.log(arr.uniqueRegex);
//http://www1.qdfuns.com/tools.php?mod=regex
```




