# 动态规划算法

动态规划解决方案从底部开始解决问题， 将所有小问题解决掉， 然后合并成一个整体解决方案， 从而解决掉整个大问题。

## 计算斐波那契数列

[斐波那契数列](https://baike.baidu.com/item/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/99145?fr=aladdin)

斐波那契数列指的是这样一个数列 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233，377，610，987，1597，2584，4181，6765，10946，17711，28657，46368........

这个数列从第3项开始，每一项都等于前两项之和。

针对这个数列，可以用一个递归的函数去计算第n项 数值

### 递归解法

```
function fib(n) {
    if(n < 2) {
        return n;
    } else{
        return fib(n - 1) + fib(n - 2);
    }
}
console.log(fib(10)); // 55
```


### 动态规划解法

从程序中我们可以看出，初始化了一个和传入等长的空数组，去存放每次运算厚的结果。
通过数组temp保存了中间结果，如果要计算的斐波那契数是1或者2，那么if语句会返回1。否则，数值1和2将被保存在temp数组中1和2的位置。
循环将会从3到输入的参数n之间进行遍历，将数组的每个元素赋值为前两个元素之和，循环结束，数组的最后一个元素值即为最终计算得到的斐波那契数值，这个数值也将作为函数的返回值。 

```
function fibDyn(n){
    var temp = [];
    for(var i = 0; i <= n; i++){
        temp[i] = 0
    }
    if(n == 1 || n == 2){
        return 1;
    }else{
        temp[1] = 1;
        temp[2] = 2; 
        for(var i = 3; i < n; i++){
            temp[i] = temp[i - 1] + temp[i -2];
        }
        return temp[i - 1];
    }
}
fibDyn(10)  // 55
```


```
console.time('fib');
fib(10);
console.timeEnd('fib');
```

```
console.time('fib');
fibDyn(10);
console.timeEnd('fib');
```

**通过运行时间的比较，动态规划的解决方案要比递归解决方案高效很多**

### 迭代版本解法

你或许已经意识到在使用迭代的方案计算斐波那契数列时， 是可以不使用数组的。
需要用到数组的原因是因为动态规划算法通常需要将中间结果保存起来。
这时候我们可以看到少了创建数组这一步，效率提升，空间复杂度变小。

```
function fibIter(n){
    var prev = 1;
    var middle = 1;
    var result = 1;

    for(var i = 2; i < n; i++){
        result = prev + middle;
        prev = middle;
        middle = result;
    }
    return result;
}
fibIter(10)  // 55
```

```
console.time('fib');
fibIter(10);
console.timeEnd('fib');
```

# 寻找最长子串：给定两个字符串,求出它们的最长公共字串

说明：比如在单词"abcdefg"和"abcdefg"它们的最长公共子序列是"abcd"。寻找最长子序列常用于遗传学中，用于使用核苷酸碱基的首字母对DNA的描述（这段话从网上抄的）。

最长公共子串和最长公共子序列的区别。

最长公共子串和最长公共子序列的区别为：子串是串的一个连续的部分，子序列则是从不改变序列的顺序，而从序列中去掉任意的元素而获得新的序列；也就是说，子串中字符的位置必须是连续的，子序列则可以不必连续。

这道题，想了很长时间，终于慢慢的把题目做出来了，接下来的内容可能会很难理解，也许我比较笨吧至少对我来说想了好久。我会尽量结合图文去展示解题的思路，也可以自己想想，然后在看接下来的内容。


## 动态规划

我们回顾一下动态规划的解题思路：

- 从底部开始解决问题，将所有小问题解决掉，然后合并成一个整体的解决方案。
- 使用一个数组建立一张表，用于存放被分解成众多子问题的解。





## 《数据结构与算法Javascript描述》寻找最长公共子串

另一个适合使用动态规划去解决的问题是寻找两个字符串的最长公共子串。例如，在单词 “raven”和“havoc”中，最长的公共子串是“av”。寻找最长公共子串常用于遗传学中，
用于使用核苷酸中碱基的首字母对 DNA 分子进行描述。

我们从暴力方式开始去解决这个问题。给出两个字符串 A 和 B，我们可以通过从 A 的第一个字符开始与 B 的对应的每一个字符进行比对的方式找到它们的最长公共子串。如果此时没有找到匹配的字母，则移动到 A 的第二个字符处，然后从 B 的第一个字符处进行比对，以此类推。

动态规划是更适合解决这个问题的方案。这个算法使用一个二维数组存储两个字符串相同 位置的字符比较结果。初始化时，该数组的每一个元素被设置为 0。每次在这两个数组的 相同位置发现了匹配，就将数组对应行和列的元素加 1，否则保持为 0。
按照这种方式，一个变量会持续记录下找到了多少个匹配项。当算法执行完毕时，这个变 量会结合一个索引变量来获得最长公共子串。

例 14-2 展示了该算法的完整定义。看完代码之后，我们将解释它是如何运行的。

例 14-2 用于确定两个字符串中最长公共子串的函数

```js
function lcs(word1, word2) {
    var max = 0;
    var index = 0;
    var lcsarr = new Array(word1.length + 1);
    for (var i = 0; i <= word1.length + 1; ++i) {
        lcsarr[i] = new Array(word2.length + 1);
        for (var j = 0; j <= word2.length + 1; ++j) {
            lcsarr[i][j] = 0;
        }
    }
    for (var i = 0; i <= word1.length; ++i) {
       for (var j = 0; j <= word2.length; ++j) {
            if (i == 0 || j == 0) {
                lcsarr[i][j] = 0;
            } else {
                if (word1[i - 1] == word2[j - 1]) {
                    lcsarr[i][j] = lcsarr[i - 1][j - 1] + 1;
                } else {
                    lcsarr[i][j] = 0;
                } 
            }
            if (max < lcsarr[i][j]) {
                max = lcsarr[i][j];
                index = i;
            }
        }
    }
    var str = "";
    if (max == 0) {
       return "";
    } else {
        for (var i = index - max; i <= max; ++i) {
          str += word2[i];
        }
        return str;
    }
}
```

该函数的第一部分初始化了两个变量以及一个二维数组。多数语言对二维数组的声明都很简单，但在 JavaScript中需要很费劲地在一个数组中定义另一个数组，这样才能声明一个二维数组。以下代码片段中的最后一个 for 循环会对这个数组进行初始化，以下是这个函数的第一部分代码:

```js
function lcs(word1, word2) {
    var max = 0;
    var index = 0;
    var lcsarr = new Array(word1.length + 1);
    for (var i = 0; i <= word1.length + 1; ++i) {
       lcsarr[i] = new Array(word2.length + 1);
       for (var j = 0; j <= word2.length + 1; ++j) {
          lcsarr[i][j] = 0;
       }
    }
}
```


接下来是这是个函数的第二部分代码:

```js
for (var i = 0; i <= word1.length; ++i) {
   for (var j = 0; j <= word2.length; ++j) {
        if (i == 0 || j == 0) {
            lcsarr[i][j] = 0;
        } else {
            if (word1[i - 1] == word2[j - 1]) {
                lcsarr[i][j] = lcsarr[i - 1][j - 1] + 1;
            } else {
                lcsarr[i][j] = 0;
            } 
        }
        if (max < lcsarr[i][j]) {
            max = lcsarr[i][j];
            index = i;
        }
    }
}
```

第二部分构建了用于保存字符匹配记录的表。数组的第一个元素总是被设置为0。如果两个字符串相应位置的字符进行了匹配，当前数组元素的值将被设置为前一次循环中数组元素保存的值加1。比如，如果两个字符串"back"和"cace"，当算法运行到第二个字符处时，那么数值1将被保存到当前元素中，因为前一个元素并不匹配，0被保存在那个元素中(0+1)。

接下来算法移动到下一个位置，由于此时两个字符仍被匹配，当前数组元素将 被设置为2(1+1)。由于两个字符串的最后一个字符不匹配，所以最长公共子串的长度是2。最后，如果变量max的值比现在存储在数组中的当前元素要小，max的值将被赋值给这个元素，变量index的值将被设置为i的当前值。这两个变量将在函数的最后一部分用于确定从哪里开始获取最长公共子串。

例如，给出两个字符串 "abbcc" 和 "dbbcc"，数组lcsarr的状态展示了算法的执行过程:
```
00000
00000
01100
01200
00031
00014
```
最后一部分代码用于确认从哪里开始构建这个最长公共子串。以变量index减去变量max的差值作为起始点，以变量max的值作为终点:

```js
var str = "";
if (max == 0) {
    return "";
} else {
    for (var i = index - max; i <= max; ++i) {
       str += word2[i];
    }
    return str; 
}
```

再次执行这个程序，对字符串 "abbcc" 和 "dbbcc" 执行后返回的结果是 "bbcc"。





