
面试题知识点
------------

**HTML&CSS：**

对Web标准的理解、浏览器内核差异、兼容性、hack、CSS基本功：布局、盒子模型、选择器优先级、HTML5、CSS3、Flexbox

**JavaScript：**

数据类型、运算、对象、Function、继承、闭包、作用域、原型链、事件、RegExp、JSON、Ajax、DOM、BOM、内存泄漏、跨域、异步装载、模板引擎、前端MVC、路由、模块化、Canvas、ECMAScript 6、Nodejs、编程规范
  
**其他：**
移动端、响应式、自动化构建、HTTP、离线存储、WEB安全、优化、重构、团队协作、可维护、易用性、SEO、UED、架构、职业生涯、快速学习能力、BOM、DOM

**无论工作年头长短都应该掌握的知识点**：

1、DOM结构 —— 两个节点之间可能存在哪些关系以及如何在节点之间任意移动。

2、DOM操作 ——如何添加、移除、移动、复制、创建和查找节点等。

3、事件 —— 如何使用事件，以及IE和标准DOM事件模型之间存在的差别。

4、XMLHttpRequest —— 这是什么、怎样完整地执行一次GET请求、怎样检测错误。

5、严格模式与混杂模式 —— 如何触发这两种模式，区分它们有何意义。

6、盒模型 —— 外边距、内边距和边框之间的关系，及IE8以下版本的浏览器中的盒模型

7、块级元素与行内元素 —— 怎么用CSS控制它们、以及如何合理的使用它们

8、浮动元素 ——怎么使用它们、它们有什么问题以及怎么解决这些问题。

9、HTML与XHTML ——二者有什么区别，你觉得应该使用哪一个并说出理由。

10、JSON —— 作用、用途、设计结构。

**备注：**

根据自己需要选择性了解，面试题是对理论知识的总结，另外也要让自己学会应该如何表达。


https://github.com/ouvens/front-end-interview-questions/blob/master/README.md




本文收集总结了一些前端面试题，初学者阅后也要用心钻研其中的原理，重要知识需要系统学习、透彻学习，形成自己的知识链。万不可投机取巧，临时抱佛脚只求面试侥幸混过关是错误的！也是不可能的！不可能的！不可能的！

前端还是一个年轻的行业，新的行业标准，框架，库都不断在更新和新增，正如赫门在2015深JS大会上的《前端服务化之路》主题演讲中说的一句话："每18至24个月，前端都会难一倍"，这些变化使前端的能力更加丰富、创造的应用也会更加完美。所以关注各种前端技术，跟上快速变化的节奏，也是身为一个前端程序员必备的技能之一。

最近也收到许多微博私信的鼓励和更正题目信息，后面会经常更新题目和答案到github博客。希望前端er达到既能使用也会表达，对理论知识有自己的理解。可根据下面的知识点一个一个去进阶学习，形成自己的职业技能链。

面试有几点需注意：(来源寒冬winter 老师，github:@wintercn)

1. 面试题目：根据你的等级和职位的变化，入门级到专家级，广度和深度都会有所增加。
2. 题目类型：理论知识、算法、项目细节、技术视野、开放性题、工作案例。
3. 细节追问： 可以确保问到你开始不懂或面试官开始不懂为止，这样可以大大延展题目的区分度和深度，知道你的实际能力。因为这种知识关联是长时期的学习，临时抱佛脚绝对是记不住的。
4. 回答问题再棒，面试官（可能是你面试职位的直接领导），会考虑我要不要这个人做我的同事？所以态度很重要、除了能做事，还要会做人（感觉更像是相亲）。
5. 资深的前端开发能把absolute和relative弄混，这样的人不要也罢，因为团队需要的是：你这个人具有可以依靠的才能（靠谱）。

前端开发知识点：

HTML&CSS：

    对Web标准的理解、浏览器内核差异、兼容性、hack、CSS基本功：布局、盒子模型、选择器优先级、
    HTML5、CSS3、Flexbox

JavaScript：

    数据类型、运算、对象、Function、继承、闭包、作用域、原型链、事件、RegExp、JSON、Ajax、
    DOM、BOM、内存泄漏、跨域、异步装载、模板引擎、前端MVC、路由、模块化、Canvas、ECMAScript6、Nodejs

其他：

    移动端、响应式、自动化构建、HTTP、离线存储、WEB安全、优化、重构、团队协作、可维护、易用性、SEO、UED、架构、职业生涯、快速学习能力
    
作为一名前端工程师，无论工作年头长短都应该掌握的知识点：
此条由王子墨发表在攻城师的实验室 http://lab.yuanwai.wang/

1. DOM结构 —— 两个节点之间可能存在哪些关系以及如何在节点之间任意移动。
2. DOM操作 —— 如何添加、移除、移动、复制、创建和查找节点等。
3. 事件 —— 如何使用事件，以及IE和标准DOM事件模型之间存在的差别。
4. XMLHttpRequest —— 这是什么、怎样完整地执行一次GET请求、怎样检测错误。
5. 严格模式与混杂模式 —— 如何触发这两种模式，区分它们有何意义。
6. 盒模型 —— 外边距、内边距和边框之间的关系，及IE8以下版本的浏览器中的盒模型
7. 块级元素与行内元素 —— 怎么用CSS控制它们、以及如何合理的使用它们
8. 浮动元素 —— 怎么使用它们、它们有什么问题以及怎么解决这些问题。
9. HTML与XHTML —— 二者有什么区别，你觉得应该使用哪一个并说出理由。
10. JSON —— 作用、用途、设计结构。

备注：
根据自己需要选择性阅读，面试题是对理论知识的总结，让自己学会应该如何表达。
资料答案不够正确和全面，欢迎欢迎Star和提交issues。
格式不断修改更新中。
更新记录：
2016年3月25日：新增ECMAScript6相关问题

HTML
-----

**Doctype作用？标准模式与兼容模式各有什么区别？**

1. DOCTYPE声明位于HTML文档中的第一行，处于html标签之前。告知浏览器的解析器用什么文档标准解析这个文档。DOCTYPE不存在或格式不正确会导致文档以兼容模式呈现。
2. 标准模式的排版和JS运作模式都是以该浏览器支持的最高标准运行。在兼容模式中，页面以宽松的向后兼容的方式显示,模拟老式浏览器的行为以防止站点无法工作。

**HTML5为什么只需要写<!DOCTYPE HTML>？**

HTML5不基于SGML，因此不需要对DTD进行引用，但是需要doctype来规范浏览器的行为（让浏览器按照它们应该的方式来运行）；而HTML4.01基于SGML,所以需要对DTD进行引用，才能告知浏览器文档所使用的文档类型。

**行内元素有哪些？块级元素有哪些？空(void)元素有那些？**

首先CSS规范规定，每个元素都有display属性，确定该元素的类型，每个元素都有默认的display值，如div的display默认值为block，则为块级元素；span默认display属性值为inline，是行内元素。

1. 行内元素有：a b span img input select strong（强调的语气）
2. 块级元素有：div ul ol li dl dt dd h1 h2 h3 h4…p
3. 常见的空元素：<br> <hr> <img> <input> <link> <meta> 鲜为人知的是：<area> <base> <col> <command> <embed> <keygen> <param> <source> <track> <wbr>

**页面导入样式时，使用link和@import有什么区别？**

1. link属于XHTML标签，除了加载CSS外，还能用于定义RSS, 定义rel连接属性等作用；而@import是CSS提供的，只能用于加载CSS;
2. 页面被加载时，link会同时被加载，而@import引用的CSS会等到页面被加载完再加载;
3. import是CSS2.1 提出的，只在IE5以上才能被识别，而link是XHTML标签，无兼容问题;

**介绍一下你对浏览器内核的理解？**

主要分成两部分：渲染引擎(layout engineer或Rendering Engine)和JS引擎。
渲染引擎：负责取得网页的内容（HTML、XML、图像等等）、整理讯息（例如加入CSS等），以及计算网页的显示方式，然后会输出至显示器或打印机。浏览器的内核的不同对于网页的语法解释会有不同，所以渲染的效果也不相同。所有网页浏览器、电子邮件客户端以及其它需要编辑、显示网络内容的应用程序都需要内核。

JS引擎则：解析和执行javascript来实现网页的动态效果。

最开始渲染引擎和JS引擎并没有区分的很明确，后来JS引擎越来越独立，内核就倾向于只指渲染引擎。

**常见的浏览器内核有哪些？**

Trident内核：IE,MaxThon,TT,The World,360,搜狗浏览器等。[又称MSHTML]
Gecko内核：Netscape6及以上版本，FF,MozillaSuite/SeaMonkey等
Presto内核：Opera7及以上。      [Opera内核原为：Presto，现为：Blink;]
Webkit内核：Safari,Chrome等。   [ Chrome的：Blink（WebKit的分支）]

**html5有哪些新特性、移除了那些元素？如何处理HTML5新标签的浏览器兼容问题？如何区分HTML和HTML5？**

* HTML5现在已经不是SGML的子集，主要是关于图像，位置，存储，多任务等功能的增加。
  
  绘画canvas;
  用于媒介回放的video和audio元素;
  本地离线存储localStorage长期存储数据，浏览器关闭后数据不丢失;
  sessionStorage的数据在浏览器关闭后自动删除;
  语意化更好的内容元素，比如 article、footer、header、nav、section;
  表单控件，calendar、date、time、email、url、search;
  新的技术webworker, websocket, Geolocation;

  移除的元素：
  
      纯表现的元素：basefont，big，center，font, s，strike，tt，u;
      对可用性产生负面影响的元素：frame，frameset，noframes；

* 支持HTML5新标签：
  
  IE8/IE7/IE6支持通过document.createElement方法产生的标签，
  可以利用这一特性让这些浏览器支持HTML5新标签，
  浏览器支持新标签后，还需要添加标签默认的样式。
  当然也可以直接使用成熟的框架、比如html5shim;
  <!--[if lt IE 9]>
  <script> src="http://html5shim.googlecode.com/svn/trunk/html5.js"</script>
  <![endif]-->

* 如何区分HTML5：DOCTYPE声明\新增的结构元素\功能元素

**简述一下你对HTML语义化的理解？**

用正确的标签做正确的事情。
html语义化让页面的内容结构化，结构更清晰，便于对浏览器、搜索引擎解析;
即使在没有样式CSS情况下也以一种文档格式显示，并且是容易阅读的;
搜索引擎的爬虫也依赖于HTML标记来确定上下文和各个关键字的权重，利于SEO;
使阅读源代码的人对网站更容易将网站分块，便于阅读维护理解。

**HTML5的离线储存怎么使用，工作原理能不能解释一下？**

在用户没有与因特网连接时，可以正常访问站点或应用，在用户与因特网连接时，更新用户机器上的缓存文件。
原理：HTML5的离线存储是基于一个新建的.appcache文件的缓存机制(不是存储技术)，通过这个文件上的解析清单离线存储资源，这些资源就会像cookie一样被存储了下来。之后当网络在处于离线状态下时，浏览器会通过被离线存储的数据进行页面展示。

如何使用：
1. 页面头部像下面一样加入一个manifest的属性；
2. 在cache.manifest文件的编写离线存储的资源；
    CACHE MANIFEST
    #v0.11
    CACHE:
    js/app.js
    css/style.css
    NETWORK:
    resourse/logo.png
    FALLBACK:
    / /offline.html
3. 在离线状态时，操作window.applicationCache进行需求实现。

**浏览器是怎么对HTML5的离线储存资源进行管理和加载的呢？**

在线的情况下，浏览器发现html头部有manifest属性，它会请求manifest文件，如果是第一次访问app，那么浏览器就会根据manifest文件的内容下载相应的资源并且进行离线存储。如果已经访问过app并且资源已经离线存储了，那么浏览器就会使用离线的资源加载页面，然后浏览器会对比新的manifest文件与旧的manifest文件，如果文件没有发生改变，就不做任何操作，如果文件改变了，那么就会重新下载文件中的资源并进行离线存储。
离线的情况下，浏览器就直接使用离线存储的资源。

**请描述一下cookies，sessionStorage和localStorage的区别？**

cookie是网站为了标示用户身份而储存在用户本地终端（Client Side）上的数据（通常经过加密）。
cookie数据始终在同源的http请求中携带（即使不需要），即会在浏览器和服务器间来回传递。
sessionStorage和localStorage不会自动把数据发给服务器，仅在本地保存。

存储大小：
    cookie数据大小不能超过4k。
    sessionStorage和localStorage虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大。

有期时间：
    localStorage    存储持久数据，浏览器关闭后数据不丢失除非主动删除数据；
    sessionStorage  数据在当前浏览器窗口关闭后自动删除。
    cookie          设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭
    
**iframe有那些缺点？**

* iframe会阻塞主页面的Onload事件；
* 搜索引擎的检索程序无法解读这种页面，不利于SEO;
* iframe和主页面共享连接池，而浏览器对相同域的连接有限制，所以会影响页面的并行加载。

使用iframe之前需要考虑这两个缺点。如果需要使用iframe，最好是通过javascript动态给iframe添加src属性值，这样可以绕开以上两个问题。

**Label的作用是什么？是怎么用的？**

label标签来定义表单控制间的关系,当用户选择该标签时，浏览器会自动将焦点转到和标签相关的表单控件上。
```
<label for="Name">Number:</label>
<input type=“text“name="Name" id="Name"/>
<label>Date:<input type="text" name="B"/></label>
```

**HTML5的form如何关闭自动完成功能？**

给不想要提示的form或某个input设置为autocomplete=off。

**如何实现浏览器内多个标签页之间的通信? (阿里)**

WebSocket、SharedWorker；也可以调用localstorge、cookies等本地存储方式；
localstorge另一个浏览上下文里被添加、修改或删除时，它都会触发一个事件，
我们通过监听事件，控制它的值来进行页面信息通信；
注意quirks：Safari 在无痕模式下设置localstorge值时会抛出QuotaExceededError的异常；


**webSocket如何兼容低浏览器？(阿里)**

Adobe Flash Socket 、
ActiveX HTMLFile (IE) 、
基于multipart编码发送 XHR 、
基于长轮询的XHR

**页面可见性（Page Visibility API）可以有哪些用途？**

通过visibilityState的值检测页面当前是否可见，以及打开网页的时间等;
在页面被切换到其他后台进程的时候，自动暂停音乐或视频的播放；

**如何在页面上实现一个圆形的可点击区域？**

1. map+area或者svg
2. border-radius
3. 纯js实现,需要求一个点在不在圆上简单算法、获取鼠标坐标等等

**实现不使用border画出1px高的线，在不同浏览器的标准模式与怪异模式下都能保持一致的效果。**
```
<div style="height:1px;overflow:hidden;background:red"></div>
```

**网页验证码是干嘛的，是为了解决什么安全问题。**

区分用户是计算机还是人的公共全自动程序。可以防止恶意破解密码、刷票、论坛灌水；
有效防止黑客对某一个特定注册用户用特定程序暴力破解方式进行不断的登陆尝试。

**title与h1的区别、b与strong的区别、i与em的区别？**

title属性没有明确意义只表示是个标题，h1则表示层次明确的标题，对页面信息的抓取也有很大的影响；
strong是标明重点内容，有语气加强的含义，使用阅读设备阅读网络时：<strong>会重读，而<B>是展示强调内容。
i内容展示为斜体，em表示强调的文本；

Physical Style Elements -- 自然样式标签 b, i, u, s, pre
Semantic Style Elements -- 语义样式标签 strong, em, ins, del, code
应该准确使用语义样式标签, 但不能滥用, 如果不能确定时首选使用自然样式标签。


CSS
----

**介绍一下标准的CSS的盒子模型？低版本IE的盒子模型有什么不同的？**

1. 有两种，IE盒子模型、W3C盒子模型；
2. 盒模型：内容(content)、填充(padding)、边界(margin)、 边框(border)；
3. 区  别：IE的content部分把 border 和 padding计算了进去;

**CSS选择符有哪些？哪些属性可以继承？**

* 1.id选择器（#myid）
  2.类选择器（.myclassname）
  3.标签选择器（div, h1, p）
  4.相邻选择器（h1 + p）
  5.子选择器（ul > li）
  6.后代选择器（li a）
  7.通配符选择器（ * ）
  8.属性选择器（a[rel = "external"]）
  9.伪类选择器（a:hover, li:nth-child）

* 可继承的样式： font-size font-family color, UL LI DL DD DT;
* 不可继承的样式：border padding margin width height ;

**CSS优先级算法如何计算？**

* 优先级就近原则，同权重情况下样式定义最近者为准;
* 载入样式以最后载入的定位为准;

优先级为:
  !important >  id > class > tag
  !important比内联优先级高
  
**CSS3新增伪类有那些？**

举例：
    p:first-of-type 选择属于其父元素的首个p元素的每个p元素。
    p:last-of-type  选择属于其父元素的最后p元素的每个p元素。
    p:only-of-type  选择属于其父元素唯一的p元素的每个p元素。
    p:only-child    选择属于其父元素的唯一子元素的每个p元素。
    p:nth-child(2)  选择属于其父元素的第二个子元素的每个p元素。
    :after          在元素之前添加内容,也可以用来做清除浮动。
    :before         在元素之后添加内容
    :enabled        
    :disabled       控制表单控件的禁用状态。
    :checked        单选框或复选框被选中。

**如何居中div？如何居中一个浮动元素？如何让绝对定位的div居中？**

给div设置一个宽度，然后添加margin:0 auto属性
```
div{
  width:200px;
  margin:0 auto;
}
```

居中一个浮动元素

  确定容器的宽高：宽500，高300的层
  设置层的外边距
  ```
 .div {
    width:500px ; height:300px;//高度可以不设
    margin: -150px 0 0 -250px;
    position:relative;         //相对定位
    background-color:pink;     //方便看效果
    left:50%;
    top:50%;
 }
 ```
 
 让绝对定位的div居中
 ```
  position: absolute;
  width: 1200px;
  background: none;
  margin: 0 auto;
  top: 0;
  left: 0;
  bottom: 0;
  right: 0;
```

**display有哪些值？说明他们的作用。**

block         象块类型元素一样显示。
none          缺省值。象行内元素类型一样显示。
inline-block  象行内元素一样显示，但其内容象块类型元素一样显示。
list-item     象块类型元素一样显示，并添加样式列表标记。
table         此元素会作为块级表格来显示
inherit       规定应该从父元素继承 display 属性的值

**position的值relative和absolute定位原点是？**

absolute
生成绝对定位的元素，相对于值不为static的第一个父元素进行定位。
fixed（老IE不支持）
生成绝对定位的元素，相对于浏览器窗口进行定位。
relative
生成相对定位的元素，相对于其正常位置进行定位。
static
默认值。没有定位，元素出现在正常的流中（忽略 top, bottom, left, right z-index 声明）。
inherit
规定从父元素继承position属性的值。

**CSS3有哪些新特性？**

新增各种CSS选择器 （:not(.input)：所有class不是“input”的节点）
圆角              （border-radius:8px）
多列布局          （multi-column layout）
阴影和反射        （Shadow\Reflect）
文字特效          （text-shadow）
文字渲染          （Text-decoration）
线性渐变          （gradient）
旋转              （transform）
增加了旋转,缩放,定位,倾斜,动画,多背景
transform:\scale(0.85,0.90)\ translate(0px,-30px)\ skew(-9deg,0deg)\Animation:

**请解释一下CSS3的Flexbox（弹性盒布局模型）,以及适用场景？**



**用纯CSS创建一个三角形的原理是什么？**

把上、左、右三条边隐藏掉（颜色设为 transparent）
```
#demo {
  width: 0;
  height: 0;
  border-width: 20px;
  border-style: solid;
  border-color: transparent transparent red transparent;
}
```

**一个满屏品字布局如何设计?**

简单的方式：
上面的div宽100%，
下面的两个div分别宽50%，
然后用float或者inline使其不换行即可

**经常遇到的浏览器的兼容性有哪些？原因，解决方法是什么，常用hack的技巧？**

* png24位的图片在IE6浏览器上出现背景，解决方案是做成PNG8.

* 浏览器默认的margin和padding不同。解决方案是加一个全局的*{margin:0;padding:0;}来统一。

* IE6双边距bug:块属性标签float后，又有横行的margin情况下，在ie6显示margin比设置的大。

  浮动ie产生的双倍距离 #box{ float:left; width:10px; margin:0 0 0 100px;}

  这种情况之下IE会产生20px的距离，解决方案是在float的标签样式控制中加入_display:inline将其转化为行内属性。_这个符号只有ie6会识别

  渐进识别的方式，从总体中逐渐排除局部。

  首先，巧妙的使用“\9”这一标记，将IE游览器从所有情况中分离出来。
  接着，再次使用“+”将IE8和IE7、IE6分离开来，这样IE8已经独立识别。

  css
    
  .bb{
      background-color:#f1ee18;/*所有识别*/
      .background-color:#00deff\9; /*IE6、7、8识别*/
      +background-color:#a200ff;/*IE6、7识别*/
      _background-color:#1e0bd1;/*IE6识别*/
  }

* IE下,可以使用获取常规属性的方法来获取自定义属性,
  也可以使用getAttribute()获取自定义属性;
  Firefox下,只能使用getAttribute()获取自定义属性。
  解决方法:统一通过getAttribute()获取自定义属性。

* IE下,even对象有x,y属性,但是没有pageX,pageY属性;
  Firefox下,event对象有pageX,pageY属性,但是没有x,y属性。

* 解决方法：（条件注释）缺点是在IE浏览器下可能会增加额外的HTTP请求数。

* Chrome中文界面下默认会将小于12px的文本强制按照12px显示,
  
-webkit-transform: scale(0.75); 12*0.75 =9
注意：transform：scale()针对块级元素，会影响文字所在容器缩放。
注意：-webkit-text-size-adjust:none;只支持到chrome-27.0，现在最新版本为48.0

超链接访问过后hover样式就不出现了被点击访问过的超链接样式不在具有hover和active了解决方法是改变CSS属性的排列顺序:
L-V-H-A :  a:link {} a:visited {} a:hover {} a:active {}

**li与li之间有看不见的空白间隔是什么原因引起的？有什么解决办法？**

行框的排列会受到中间空白（回车\空格）等的影响，因为空格也属于字符,这些空白也会被应用样式，占据空间，所以会有间隔，把字符大小设为0，就没有空格了。

**为什么要初始化CSS样式？**

因为浏览器的兼容问题，不同浏览器对有些标签的默认值是不同的，如果没对CSS初始化往往会出现浏览器之间的页面显示差异。
当然，初始化样式会对SEO有一定的影响，但鱼和熊掌不可兼得，但力求影响最小的情况下初始化。

最简单的初始化方法： *{padding: 0; margin: 0;} （强烈不建议）

淘宝的样式初始化代码：
```
body, h1, h2, h3, h4, h5, h6, hr, p, blockquote, dl, dt, dd, ul, ol, li, pre, form, fieldset, legend, button, input, textarea, th, td { margin:0; padding:0; }
body, button, input, select, textarea { font:12px/1.5tahoma, arial, \5b8b\4f53; }
h1, h2, h3, h4, h5, h6{ font-size:100%; }
address, cite, dfn, em, var { font-style:normal; }
code, kbd, pre, samp { font-family:couriernew, courier, monospace; }
small{ font-size:12px; }
ul, ol { list-style:none; }
a { text-decoration:none; }
a:hover { text-decoration:underline; }
sup { vertical-align:text-top; }
sub{ vertical-align:text-bottom; }
legend { color:#000; }
fieldset, img { border:0; }
button, input, select, textarea { font-size:100%; }
table { border-collapse:collapse; border-spacing:0; }
```

**absolute的containing block(容器块)计算方式跟正常流有什么不同？**

无论属于哪种，都要先找到其祖先元素中最近的position值不为static的元素，然后再判断：
1. 若此元素为inline元素，则containing block为能够包含这个元素生成的第一个和最后一个inline box的padding box (除margin, border外的区域) 的最小矩形；
2. 否则，则由这个祖先元素的padding box构成。
如果都找不到，则为initial containing block。

补充：
1. static(默认的)/relative：简单说就是它的父元素的内容框（即去掉padding的部分）
2. absolute: 向上找最近的定位为absolute/relative的元素
3. fixed: 它的containing block一律为根元素(html/body)，根元素也是initial containing block

**CSS里的visibility属性有个collapse属性值是干嘛用的？在不同浏览器下以后什么区别？**

**position跟display、margin collapse、overflow、float这些特性相互叠加后会怎么样？**

**对BFC规范(块级格式化上下文：block formatting context)的理解？**

（W3C CSS 2.1 规范中的一个概念，它是一个独立容器，决定了元素如何对其内容进行定位，以及与其他元素的关系和相互作用。）
 一个页面是由很多个Box组成的，元素的类型和display属性,决定了这个Box的类型。
 不同类型的Box，会参与不同的FormattingContext（决定如何渲染文档的容器），因此Box内的元素会以不同的方式渲染，也就是说BFC内部的元素和外部的元素不会互相影响。
 
**css定义的权重**

以下是权重的规则：标签的权重为1，class的权重为10，id的权重为100，以下例子是演示各种定义的权重值：

```
/*权重为1*/
div{
}
/*权重为10*/
.class1{
}
/*权重为100*/
#id1{
}
/*权重为100+1=101*/
#id1 div{
}
/*权重为10+1=11*/
.class1 div{
}
/*权重为10+10+1=21*/
.class1 .class2 div{
}
```
如果权重相同，则最后定义的样式会起作用，但是应该避免这种情况出现。

**请解释一下为什么会出现浮动和什么时候需要清除浮动？清除浮动的方式**

**移动端的布局用过媒体查询吗？**

**使用CSS预处理器吗？喜欢那个？**

SASS (SASS、LESS没有本质区别，只因为团队前端都是用的SASS)

**CSS优化、提高性能的方法有哪些？**

**浏览器是怎样解析CSS选择器的？**

**在网页中的应该使用奇数还是偶数的字体？为什么呢？**

**margin和padding分别适合什么场景使用？**

**抽离样式模块怎么写，说出思路，有无实践经验？[阿里航旅的面试题]**

**元素竖向的百分比设定是相对于容器的高度吗？**

**全屏滚动的原理是什么？用到了CSS的那些属性？**

**瀑布流的原理是什么？有哪些实现方法？**

**什么是响应式设计？响应式设计的基本原理是什么？如何兼容低版本的IE？**

**视差滚动效果，如何给每页做不同的动画？（回到顶部，向下滑动要再次出现，和只出现一次分别怎么做？）**

**::before 和 :after中双冒号和单冒号 有什么区别？解释一下这2个伪元素的作用。**

**如何修改chrome记住密码后自动填充表单的黄色背景？**

**你对line-height是如何理解的？**

**设置元素浮动后，该元素的display值是多少？（自动变成display:block）**

**怎么让Chrome支持小于12px 的文字？**

**让页面里的字体变清晰，变细用CSS怎么做？（-webkit-font-smoothing: antialiased;）**

**font-style属性可以让它赋值为"oblique" oblique是什么意思？**

**position:fixed;在android下无效怎么处理？**

**如果需要手动写动画，你认为最小时间间隔是多久，为什么？（阿里）**

多数显示器默认频率是60Hz，即1秒刷新60次，所以理论上最小间隔为1/60＊1000ms ＝ 16.7ms

**display:inline-block什么时候会显示间隙？(携程)**

移除空格、使用margin负值、使用font-size:0、letter-spacing、word-spacing

**overflow: scroll时不能平滑滚动的问题怎么处理？**

**有一个高度自适应的div，里面有两个div，一个高度100px，希望另一个填满剩下的高度。**

**png、jpg、gif这些图片格式解释一下，分别什么时候用。有没有了解过webp？**

**什么是Cookie 隔离？（或者说：请求资源的时候不要让它带cookie怎么做）**

如果静态文件都放在主域名下，那静态文件请求的时候都带有的cookie的数据提交给server的，非常浪费流量，
所以不如隔离开。

因为cookie有域的限制，因此不能跨域提交请求，故使用非主要域名的时候，请求头中就不会带有cookie数据，
这样可以降低请求头的大小，降低请求时间，从而达到降低整体请求延时的目的。

同时这种方式不会将cookie传入Web Server，也减少了Web Server对cookie的处理分析环节，提高了webserver的http请求的解析速度。

**style标签写在body后与body前有什么区别？**

**什么是CSS预处理器/后处理器？**

预处理器例如：LESS、Sass、Stylus，用来预编译Sass或less，增强了css代码的复用性，还有层级、mixin、变量、循环、函数等，具有很方便的UI组件模块化开发能力，极大的提高工作效率。

后处理器例如：PostCSS，通常被视为在完成的样式表中根据CSS规范处理CSS，让其更有效；目前最常做的是给CSS属性添加浏览器私有前缀，实现跨浏览器兼容性的问题。

JavaScript
----------

**介绍js的基本数据类型**

Undefined、Null、Boolean、Number、String

**介绍js有哪些内置对象？**

Object是JavaScript中所有对象的父对象

数据封装类对象：Object、Array、Boolean、Number和String
其他对象：Function、Arguments、Math、Date、RegExp、Error

**说几条写JavaScript的基本规范？**

1. 不要在同一行声明多个变量。
2. 请使用===/!==来比较true/false或者数值
3. 使用对象字面量替代new Array这种形式
4. 不要使用全局函数。
5. Switch语句必须带有default分支
6. 函数不应该有时候有返回值，有时候没有返回值。
7. For循环必须使用大括号
8. If语句必须使用大括号
9. for-in循环中的变量应该使用var关键字明确限定作用域，从而避免作用域污染。

**JavaScript原型，原型链？有什么特点？**

每个对象都会在其内部初始化一个属性，就是prototype(原型)，当我们访问一个对象的属性时，如果这个对象内部不存在这个属性，那么他就会去prototype里找这个属性，这个prototype又会有自己的prototype，于是就这样一直找下去，也就是我们平时所说的原型链的概念。

关系：instance.constructor.prototype = instance.__proto__

特点：JavaScript对象是通过引用来传递的，我们创建的每个新对象实体中并没有一份属于自己的原型副本。当我们修改原型时，与之相关的对象也会继承这一改变。

当我们需要一个属性的时，Javascript引擎会先看当前对象中是否有这个属性，如果没有的话， 就会查找他的Prototype对象是否有这个属性，如此递推下去，一直检索到Object内建对象。
```javascript
  function Func(){}
  Func.prototype.name = "Sean";
  Func.prototype.getInfo = function() {
    return this.name;
  }
  var person = new Func();//现在可以参考var person = Object.create(oldObject);
  console.log(person.getInfo());//它拥有了Func的属性和方法
  //"Sean"
  console.log(Func.prototype);
  // Func { name="Sean", getInfo=function()}
```

**JavaScript有几种类型的值？，你能画一下他们的内存图吗？**

栈：原始数据类型（Undefined，Null，Boolean，Number、String） 
堆：引用数据类型（对象、数组和函数）

两种类型的区别是：存储位置不同；
原始数据类型直接存储在栈(stack)中的简单数据段，占据空间小、大小固定，属于被频繁使用数据，所以放入栈中存储；
引用数据类型存储在堆(heap)中的对象,占据空间大、大小不固定,如果存储在栈中，将会影响程序运行的性能；引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体

**Javascript如何实现继承？**

1、构造继承
2、原型继承
3、实例继承
4、拷贝继承

原型prototype机制或apply和call方法去实现较简单，建议使用构造函数与原型混合方式。
```javascript
function Parent(){
  this.name = 'wang';
}
function Child(){
  this.age = 28;
}
Child.prototype = new Parent();//继承了Parent，通过原型
var demo = new Child();
alert(demo.age);
alert(demo.name);//得到被继承的属性
}
```

**JavaScript继承的几种实现方式？**

http://www.ruanyifeng.com/blog/2010/05/object-oriented_javascript_inheritance.html

http://www.ruanyifeng.com/blog/2010/05/object-oriented_javascript_inheritance_continued.html

**javascript创建对象的几种方式？**

javascript创建对象简单的说,无非就是使用内置对象或各种自定义对象，当然还可以用JSON；但写法有很多种，也能混合使用。


1. 对象字面量的方式   

```javascript
person={firstname:"Mark",lastname:"Yun",age:25,eyecolor:"black"};
```

2. 用function来模拟无参的构造函数

```javascript
function Person(){}
var person=new Person();//定义一个function，如果使用new"实例化",该function可以看作是一个Class
person.name="Mark";
person.age="25";
person.work=function(){
alert(person.name+" hello...");
}
person.work();
```

3. 用function来模拟参构造函数来实现（用this关键字定义构造的上下文属性）

```javascript
function Pet(name,age,hobby){
  this.name=name;//this作用域：当前对象
  this.age=age;
  this.hobby=hobby;
  this.eat=function(){
    alert("我叫"+this.name+",我喜欢"+this.hobby+",是个程序员");
  }
}
var maidou =new Pet("麦兜",25,"coding");//实例化、创建对象
maidou.eat();//调用eat方法
```

4. 用工厂方式来创建（内置对象）

```javascript
var wcDog =new Object();
wcDog.name="旺财";
wcDog.age=3;
wcDog.work=function(){
  alert("我是"+wcDog.name+",汪汪汪......");
}
wcDog.work();
```

5. 用原型方式来创建

```javascript
function Dog(){

}
Dog.prototype.name="旺财";
Dog.prototype.eat=function(){
  alert(this.name+"是个吃货");
}
var wangcai =new Dog();
wangcai.eat();
```

6. 用混合方式来创建

```javascript
function Car(name,price){
  this.name=name;
  this.price=price; 
}
Car.prototype.sell=function(){
  alert("我是"+this.name+"，我现在卖"+this.price+"万元");
}
var camry =new Car("凯美瑞",27);
camry.sell();
```


**Javascript作用链域？**

全局函数无法查看局部函数的内部细节，但局部函数可以查看其上层的函数细节，直至全局细节。
当需要从局部函数查找某一属性或方法时，如果当前作用域没有找到，就会上溯到上层作用域查找，
直至全局函数，这种组织形式就是作用域链。

**谈谈This对象的理解。**

this总是指向函数的直接调用者（而非间接调用者）；
如果有new关键字，this指向new出来的那个对象；
在事件中，this指向触发这个事件的对象，特殊的是，IE中的attachEvent中的this总是指向全局对象Window；

**eval是做什么的？**

它的功能是把对应的字符串解析成JS代码并运行；
应该避免使用eval，不安全，非常耗性能（2次，一次解析成js语句，一次执行）。
由JSON字符串转换为JSON对象的时候可以用eval，var obj =eval('('+ str +')');

**什么是window对象? 什么是document对象？**

**null，undefined的区别？**

null        表示一个对象被定义了，值为“空值”；
undefined   表示不存在这个值。

typeof undefined
    //"undefined"
    undefined :是一个表示"无"的原始值或者说表示"缺少值"，就是此处应该有一个值，但是还没有定义。当尝试读取时会返回undefined； 
    例如变量被声明了，但没有赋值时，就等于undefined

typeof null
    //"object"
    null : 是一个对象(空对象, 没有任何属性和方法)；
    例如作为函数的参数，表示该函数的参数不是对象；

注意：
    在验证null时，一定要使用　=== ，因为 == 无法分别null和undefined


再来一个例子：

  null
  Q：有张三这个人么？
  A：有！
  Q：张三有房子么？
  A：没有！

  undefined
  Q：有张三这个人么？
  A：没有！


http://www.ruanyifeng.com/blog/2014/03/undefined-vs-null.html

**写一个通用的事件侦听器函数。**

```javascript
//event(事件)工具集，来源：github.com/markyun
    markyun.Event = {
        // 页面加载完成后
        readyEvent : function(fn) {
            if (fn==null) {
                fn=document;
            }
            var oldonload = window.onload;
            if (typeof window.onload != 'function') {
                window.onload = fn;
            } else {
                window.onload = function() {
                    oldonload();
                    fn();
                };
            }
        },
        // 视能力分别使用dom0||dom2||IE方式 来绑定事件
        // 参数： 操作的元素,事件名称 ,事件处理程序
        addEvent : function(element, type, handler) {
            if (element.addEventListener) {
                //事件类型、需要执行的函数、是否捕捉
                element.addEventListener(type, handler, false);
            } else if (element.attachEvent) {
                element.attachEvent('on' + type, function() {
                    handler.call(element);
                });
            } else {
                element['on' + type] = handler;
            }
        },
        // 移除事件
        removeEvent : function(element, type, handler) {
            if (element.removeEventListener) {
                element.removeEventListener(type, handler, false);
            } else if (element.datachEvent) {
                element.detachEvent('on' + type, handler);
            } else {
                element['on' + type] = null;
            }
        },
        // 阻止事件 (主要是事件冒泡，因为IE不支持事件捕获)
        stopPropagation : function(ev) {
            if (ev.stopPropagation) {
                ev.stopPropagation();
            } else {
                ev.cancelBubble = true;
            }
        },
        // 取消事件的默认行为
        preventDefault : function(event) {
            if (event.preventDefault) {
                event.preventDefault();
            } else {
                event.returnValue = false;
            }
        },
        // 获取事件目标
        getTarget : function(event) {
            return event.target || event.srcElement;
        },
        // 获取event对象的引用，取到事件的所有信息，确保随时能使用event；
        getEvent : function(e) {
            var ev = e || window.event;
            if (!ev) {
                var c = this.getEvent.caller;
                while (c) {
                    ev = c.arguments[0];
                    if (ev && Event == ev.constructor) {
                        break;
                    }
                    c = c.caller;
                }
            }
            return ev;
        }
    };
```
